---
title: "Parsing SIDER 2"
author: "Daniel Himmelstein"
date: "January 30, 2015"
output:
  html_document:
    theme: cosmo
    highlight: pygments
    includes:
      in_header: ../include/in_header.html
      before_body: include/before_body.html
bibliography: references.bib
csl: ../cite-styles/plos-mod.csl
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(
  fig.width = 10,
  fig.path = 'figures/',
  warning = FALSE,
  message = FALSE,
  fig.retina = 2
)
```

```{r, include=FALSE}
# Set up citation management
library(knitcitations)
knitcitations::cleanbib()
knitcitations::cite_options(citation_format = 'pandoc', cite.style = 'numeric', hyperlink = 'to.bib', super = TRUE)
```

```{r, echo=FALSE}
# Code for data.tables

# Display as a javascript datatable
renderPubChem <- DT::JS(
  "function(data, type, full, meta) {",
  "return type === 'display' ? ",
  "'<a href=\"https://pubchem.ncbi.nlm.nih.gov/compound/' + ",
  "data + '\" target=\"_blank\">' + data + '</a>' : data;}")

DataTable <- function(df, dt.opts = list(), max.rows = 0) {
  if (max.rows != 0) {
    df <- df %>% dplyr::filter(row_number() <= max.rows)
  }
  DT::datatable(data = df, options = dt.opts)
}

PubchemDataTable <- function(df, ...) {
  dt.opts <- list(columnDefs =list(list(targets = which(colnames(df) == 'pubchem_cid') - 1, render = renderPubChem)))
  DataTable(df, dt.opts = dt.opts, ...)
}
```

Parsing [SIDER 2](http://sideeffects.embl.de/) `r knitcitations::citep('10.1038/msb.2009.98')` 

#### Load packages
We use [*caret*](https://topepo.github.io/caret/index.html) and [*kernlab*](http://cran.r-project.org/web/packages/kernlab/vignettes/kernlab.pdf) for machine learning; [*dplyr*](http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html) for data manipulation; [*ggplot2*](http://docs.ggplot2.org/current/) and [*scales*](https://github.com/hadley/scales) for plotting; [*DT*](https://rstudio.github.io/DT/) for displaying html tables using the Javascript [*DataTables* library](http://www.datatables.net/). For multicore parallel processing, we use the [*doMC*](http://cran.r-project.org/web/packages/doMC/vignettes/gettingstartedMC.pdf) package which is not available on Windows and can be commented out. We make extensive use of [the pipe operator](http://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html) (`dplyr::%>%`), which passes its lefthand value to the first argument of the righthand expression.

```{r, message=FALSE, warning=FALSE}
library(caret)
library(kernlab)
library(dplyr)
library(ggplot2)
library(scales)
library(DT)
library(doMC)

options(stringsAsFactors=FALSE)
doMC::registerDoMC(cores = 6)

write.delim <- function(x, file, sep='\t', quote = FALSE, row.names=FALSE, na = '', ...) {
  write.table(x = x, file = file, sep=sep, quote=quote, row.names=row.names, na=na, ...)
}
```

### Read Unprocessed SIDER 2 Data
First, we download SIDER 2 data from their [website](http://sideeffects.embl.de/download/). The three necessary files (`adverse_effects_raw.tsv.gz`, `indications_raw.tsv.gz`, `label_mapping.tsv.gz`) were reteived and and placed the `download/` directory. See the [SIDER 2 download README](http://sideeffects.embl.de/media/download/README) for file documentation. 

```{r}
Mode <- function(x) {
  # Returns the most common element in x. Only a single element is returned
  # in case of ties.
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

ReadRawSIDER <- function(path, type) {
  # Read adverse_effects_raw.tsv.gz or indications_raw.tsv.gz.
  # Count the occurrences of each concept in each label and
  # collapse label-concept pairs. 
  fieldnames <- c('label_id', 'concept_id', 'concept_name')
  path %>%
    read.table(sep='\t', col.names=fieldnames, comment.char='', quote='') %>%
    dplyr::group_by(label_id, concept_id) %>%
    dplyr::summarize(concept_name = Mode(concept_name), occurrences = n()) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(type = type)
}

# Read the raw drug label annotations
raw.df <- dplyr::bind_rows(
  file.path('..', 'download', 'adverse_effects_raw.tsv.gz') %>%
    ReadRawSIDER(type = 'side_effect'),
  file.path('..', 'download', 'indications_raw.tsv.gz') %>%
    ReadRawSIDER(type = 'indication'))

DataTable(raw.df, max.rows=200)

# Find the most commonly used name for each concept (indication/side effect)
concept.df <- raw.df %>%
  dplyr::group_by(concept_id) %>%
  dplyr::summarize(concept_name = Mode(concept_name))

DataTable(concept.df, max.rows=200)

# Read the compound to label mappings
fieldnames <- c('generic_names', 'brand_names', 'stitch_mapping',
                'stitch_id_flat', 'stitch_id_sterio', 'label_url', 'label_id')
label.df <- file.path('..', 'download', 'label_mapping.tsv.gz') %>%
  read.table(sep = '\t', col.names = fieldnames, na.strings = '', comment.char = '', quote = '') %>%
  dplyr::mutate(pubchem_cid = abs(stitch_id_sterio)) %>%
  dplyr::filter(! is.na(pubchem_cid))

label.df$pubchem_cid %>% unique() %>% sort() %>% data.frame() %>%
  write.table(file = file.path('..', 'data', 'sider_compounds_pubchem.txt'), row.names=FALSE, col.names=FALSE)

PubchemDataTable(label.df %>% dplyr::select(-stitch_mapping), max.rows=200)
```

### Create a table of all indications and side effects for compounds that mapped to pubchem.
```{r}

# Join label-specific side effects and indications to pubchem compounds
pair.df <- label.df %>%
  dplyr::select(pubchem_cid, label_id) %>%
  dplyr::distinct() %>%
  dplyr::inner_join(raw.df)

CollapseTypes <- function(df) {
  # Take a table of all the label-specific side effects and indications
  # for a single compound and collapse into a cross-label table,
  # so each concept only appears once for a given concept and type.
  total_labels <- dplyr::n_distinct(df$label_id)
  df %>%
    dplyr::group_by(type, concept_id) %>%
    dplyr::summarize(
      n_labels = n(),
      occurs_min = min(occurrences),
      #occurs_median = median(occurrences),
      occurs_max = max(occurrences),
      occurs_mean = mean(occurrences),
      occurs_mode = Mode(occurrences),
      occurs_sd = sd(occurrences),
      occurs_iqr = IQR(occurrences)
      ) %>%
    dplyr::mutate(total_labels = total_labels) %>%
    dplyr::mutate(percent_labels = n_labels / total_labels)
}

# Create a cross-label table of side effects and indications for
# all pubchem-mapped compounds.
collapsed.df <- pair.df %>%
  dplyr::group_by(pubchem_cid) %>%
  dplyr::do(CollapseTypes(.)) %>%
  dplyr::ungroup() %>%
  dplyr::left_join(concept.df) %>%
  dplyr::select(pubchem_cid, concept_id, concept_name, total_labels,
                type, n_labels, percent_labels, occurs_min:occurs_iqr)

```

```{r}

# Find the conflicting side effects and indications:
# When a compound-concept pair has been extracted
# as both a side effect and indication.
overlap.df <- dplyr::intersect(
  dplyr::filter(collapsed.df, type == 'indication') %>%
    dplyr::select(pubchem_cid:total_labels),
  dplyr::filter(collapsed.df, type == 'side_effect') %>%
    dplyr::select(pubchem_cid:total_labels))

ColNameAppend <- function(df, s) {
  keep.df <- dplyr::select(df, pubchem_cid:total_labels)
  append.df <- dplyr::select(df, n_labels:occurs_iqr)
  colnames(append.df) <- paste0(colnames(append.df), '_', s)
  dplyr::bind_cols(keep.df, append.df)
}

overlap.df <- overlap.df %>%
  dplyr::inner_join(
    dplyr::filter(collapsed.df, type == 'indication') %>% ColNameAppend(s = 'ind')) %>%
  dplyr::inner_join(
    dplyr::filter(collapsed.df, type == 'side_effect') %>% ColNameAppend(s = 'se')) %>%
  dplyr::mutate(n_label_ratio = n_labels_ind / n_labels_se,
                percent_label_ratio = percent_labels_ind / percent_labels_se) %>%
  dplyr::left_join(
    collapsed.df %>% dplyr::group_by(concept_id) %>%
    dplyr::summarize(concept_n_ind = sum(type == 'indication'),
                     concept_n_se = sum(type == 'side_effect'))) %>% 
  dplyr::left_join(
    collapsed.df %>% dplyr::group_by(pubchem_cid) %>%
    dplyr::summarize(compound_n_ind = sum(type == 'indication'),
                     compound_n_se = sum(type == 'side_effect')))
```
Overall, `r #nrow(overlap.df)` compound-concept pairs overlapped -- were extacted as both a side effect and indication.

```{r, fig.height=3.5, fig.cap='Pairs extracted as both an indication and side effect'}
overlap.gold.df <- file.path('..', 'gold', 'conflicts.txt') %>% 
  read.delim(na.strings = '', colClasses=c(category_manual='factor')) %>% 
  dplyr::select(pubchem_cid, concept_id, category_manual) %>% 
  dplyr::left_join(overlap.df)

ggplot(overlap.gold.df, aes(n_labels_se, n_labels_ind)) +
  geom_abline(intercept = 0, slope = 1, linetype='dashed', color='grey') +
  geom_point(aes(color=category_manual, size=total_labels), alpha = 0.6) +
  theme_bw() + coord_fixed() +
  scale_colour_manual(name = 'Manual Class', values = c('blue', 'red')) +
  scale_size_area(name='Total Labels', max_size = 7) +
  xlab('Side Effect Labels') + ylab('Indication Labels')
```

Manual classification was performed for `r nrow(overlap.gold.df)` side effect-indication conflicts. The prevalance of indications in this gold standard dataset was `r (mean(overlap.gold.df$category_manual == 'indication') * 100) %>% format(digits = 3)`%. 

```{r, fig.height=3.5, fig.cap='SVM Parameter Optimization'}
GetX <- function(df) {
  X <- dplyr::select(.data = df, total_labels:compound_n_se)
  X[is.na(X)] <- 0
  return(X)
}

X.gold <- GetX(overlap.gold.df)
X.overlap <- GetX(overlap.df)
y.gold <- overlap.gold.df$category_manual

set.seed(0)
control <- caret::trainControl(method = 'repeatedcv', repeats=10, classProb=TRUE)
tune.grid <- expand.grid(.sigma = kernlab::sigest(x = as.matrix(X.gold), frac = 0.5, scaled = TRUE), .C = 2 ^ (-10:2))
overlap.model <- caret::train(x = X.gold, y = y.gold, preProcess = c('center', 'scale'), 
  method = 'svmRadial', metric = 'Kappa', trControl = control, tuneGrid = tune.grid)
ggplot(overlap.model) + theme_bw() + 
  scale_x_log10(breaks = scales::trans_breaks('log2', function(x) 2 ^ x),
                labels = scales::trans_format('log2', scales::math_format(2 ^ .x)))


y.overlap.df <- predict(overlap.model, newdata = X.overlap, type = 'prob')
overlap.df$prob_ind <- y.overlap.df$indication
overlap.df$prob_se <- y.overlap.df$side_effect

# Add category_manual column
overlap.df <- overlap.df %>% dplyr::left_join(
  y = overlap.gold.df %>% dplyr::select(pubchem_cid, concept_id, category_manual))

# Save the overlap.df
overlap.df %>%
  write.table(file = file.path('..', 'data', 'overlap.txt'), sep='\t', quote = FALSE, row.names=FALSE, na = '')

```

```{r}
prob_cutoff_ind <- 0.75
prob_cutoff_se <- 0.75
stopifnot(prob_cutoff_ind + prob_cutoff_se >= 1)

indication_drop.df <- overlap.df %>%
  dplyr::filter(prob_ind < prob_cutoff_ind) %>%
  dplyr::mutate(type='indication')

side_effect_drop.df <- overlap.df %>%
  dplyr::filter(prob_se < prob_cutoff_se) %>%
  dplyr::mutate(type='side_effect')

conflict.stats <- list(
  n_ind = nrow(overlap.df) - nrow(indication_drop.df),
  n_se = nrow(overlap.df) - nrow(side_effect_drop.df),
  n_unresolved = nrow(indication_drop.df) + nrow(side_effect_drop.df) - nrow(overlap.df)
)

non_overlap.df <- collapsed.df %>%
  dplyr::anti_join(y = indication_drop.df, by = c('pubchem_cid', 'concept_id', 'type')) %>%
  dplyr::anti_join(y = side_effect_drop.df, by = c('pubchem_cid', 'concept_id', 'type'))

# set.seed(0)
# non_overlap.df %>% dplyr::filter(type == 'indication') %>% dplyr::sample_frac(1) %>%
#   write.delim(file = file.path('..', 'data', 'indications.txt'))
# non_overlap.df %>% dplyr::filter(type == 'side_effect') %>% dplyr::sample_frac(1) %>%
#   write.delim(file = file.path('..', 'data', 'side_effects.txt'))
non_overlap.df %>% 
  write.delim(file.path('..', 'data', 'sider2-processed.txt'))
```

Conflicting compound-concept pairs were classified as indications if $Prob(Indication) \geq `r prob_cutoff_ind`$ and as side effects if $Prob(Side Effect) \geq `r prob_cutoff_se`$. Of the conflicts, `r conflict.stats$n_ind` were classified as indications, `r conflict.stats$n_se` were classified as side effects, and `r conflict.stats$n_unresolved` were unresolved and excluded as both indications and side effects.

```{r, echo=FALSE}
se.df <- non_overlap.df %>% dplyr::filter(type == 'side_effect')
ind.df <- non_overlap.df %>% dplyr::filter(type == 'indication')
```

After resolving conflicts, `r nrow(se.df)` side effects remained covering `r dplyr::n_distinct(se.df$pubchem_cid)` compounds and `r dplyr::n_distinct(se.df$concept_id)` side effects. Conversely, `r nrow(ind.df)` indications remained for `r dplyr::n_distinct(ind.df$pubchem_cid)` compounds and `r dplyr::n_distinct(ind.df$concept_id)` diseases.

### Read manual indication and side-effect classifications
```{r}
non_overlap.df <- non_overlap.df %>%
  dplyr::inner_join(
    non_overlap.df %>% dplyr::group_by(concept_id) %>%
    dplyr::summarize(concept_n_ind = sum(type == 'indication'),
                     concept_n_se = sum(type == 'side_effect'))) %>% 
  dplyr::inner_join(
    non_overlap.df %>% dplyr::group_by(pubchem_cid) %>%
    dplyr::summarize(compound_n_ind = sum(type == 'indication'),
                     compound_n_se = sum(type == 'side_effect')))

gold.ind.df <- file.path('..', 'gold', 'indications.txt') %>% 
  read.delim(na.strings = '', colClasses=c(category_manual='factor')) %>% 
  dplyr::left_join(non_overlap.df)
  
gold.se.df <- file.path('..', 'gold', 'side_effects.txt') %>% 
  read.delim(na.strings = '', colClasses=c(category_manual='factor')) %>% 
  dplyr::left_join(non_overlap.df)

prop.test.ind <- sum(gold.ind.df$category_manual == 1) %>% prop.test(n = nrow(gold.ind.df))
prop.test.se <- sum(gold.se.df$category_manual == 1) %>% prop.test(n = nrow(gold.se.df))
prec.stats <- list(
  'ind.prec.est' = 100 * prop.test.ind$estimate,
  'ind.prec.lower' = 100 * prop.test.ind$conf.int[1],
  'ind.prec.upper' = 100 * prop.test.ind$conf.int[2],
  'se.prec.est' = 100 * prop.test.se$estimate,
  'se.prec.lower' = 100 * prop.test.se$conf.int[1],
  'se.prec.upper' = 100 * prop.test.se$conf.int[2]
) %>% lapply(format, digits = 3)
```

We manually evaluated `r nrow(gold.ind.df)` random indications and `r nrow(gold.se.df)` random side effects to assess the precision of automated side effect and indication extraction. The precision of indications was `r prec.stats$ind.prec.est`% [95% CI: `r prec.stats$ind.prec.lower`--`r prec.stats$ind.prec.upper`%]. The precision of side effects was `r prec.stats$se.prec.est`% [95% CI: `r prec.stats$se.prec.lower`--`r prec.stats$se.prec.upper`%]

### Can we predict which indications are false positives
```{r}
X.gold <- GetX(gold.se.df)
y.gold <- as.factor(gold.se.df$category_manual)

set.seed(0)
control <- caret::trainControl(method = 'repeatedcv', repeats=10, classProb=TRUE)
tune.grid <- expand.grid(.sigma = kernlab::sigest(x = as.matrix(X.gold), frac = 0.5, scaled = TRUE), .C = 2 ^ (-6:6))
ind.model <- caret::train(x = X.gold, y = y.gold, preProcess = c('center', 'scale'), 
  method = 'svmRadial', metric = 'Kappa', trControl = control, tuneGrid = tune.grid)
ggplot(ind.model) + theme_bw() + 
  scale_x_log10(breaks = scales::trans_breaks('log2', function(x) 2 ^ x),
                labels = scales::trans_format('log2', scales::math_format(2 ^ .x)))


```

### Vizualizing Side Effects and Indications
```{r}
# vizualizing pairs
non_overlap.df %>%
  ggplot(aes(x = as.character(pubchem_cid), y = concept_id)) + theme_bw() +
    facet_grid(type ~ ., scales = 'free_y', space = 'free_y') +
    geom_tile(fill= 'black') +
    xlab('Compound') + ylab(NULL) +
    scale_x_discrete(breaks=NULL, expand = c(0.02, 0)) + scale_y_discrete(breaks=NULL, expand = c(0.04, 0))
```

### Sample of processed output

```{r}
# Display as a javascript datatable
non_overlap.df %>%
  dplyr::select(pubchem_cid:concept_name, n_labels, total_labels, type) %>%
  PubchemDataTable(max.rows=200)
```

### Multiple Sclerosis Indications

```{r}
non_overlap.df %>%
  dplyr::select(pubchem_cid:concept_name, n_labels, total_labels, type) %>%
  dplyr::filter(concept_name == 'multiple sclerosis') %>%
  PubchemDataTable()
```


# References
```{r, include=FALSE}
knitcitations::write.bibtex(file = 'references.bib')
```